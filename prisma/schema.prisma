generator client {
  provider = "prisma-client-js"
}

generator py {
  provider             = "prisma-client-py"
  recursive_type_depth = -1
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String            @id @default(cuid())
  name          String?
  email         String?           @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  game_session  GameSession[]
  player_state  PlayerCharacter[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ====================================================================================
// GAME TABLES
// ====================================================================================

model GameSession {
  id               String            @id @default(cuid())
  is_active        Boolean           @default(false)
  created_at       DateTime          @default(now())
  updated_at       DateTime          @updatedAt
  game_id          String
  messages         ChatMessage[]
  game_state       GameState?
  player_character PlayerCharacter[]
  scene_state      SceneDiff[]

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model GameState {
  id                     String    @id @default(cuid())
  weather                String?
  in_combat              Boolean   @default(false)
  objectives             Json?
  story_beats            Json?
  time_of_day            String?
  save_version           String?
  turn_counter           Int?
  current_turn_phase     String?
  current_actor          String?
  is_player_input_locked Boolean   @default(true)
  recent_events          Json?
  session_started        DateTime?
  initiative_order       Json?
  items_discovered       Json?
  location_history       Json?
  important_npcs_met     Json?
  completed_objectives   Json?
  created_at             DateTime  @default(now())
  updated_at             DateTime  @updatedAt
  game_id                String

  game_session_id String      @unique
  game_session    GameSession @relation(fields: [game_session_id], references: [id], onDelete: Cascade)
}

model BaseCharacter {
  id             String        @id @default(cuid())
  name           String
  bio            String?
  character_type CharacterType
  creatureType   CreatureType

  condition_effects ConditionEffectInstance[]
  inventory         Inventory[]
  abilities         AbilityOnCharacter[]
  spells            SpellOnCharacter[]

  player PlayerCharacter?
  npc    NpcCharacter[]
}

model PlayerCharacter {
  id      String        @id @default(cuid())
  base_id String        @unique
  base    BaseCharacter @relation(fields: [base_id], references: [id])

  level            Int
  max_hp           Int
  current_hp       Int
  temporary_hp     Int
  armor_class      Int
  initiative       Int
  initiative_bonus Int
  strength         Int
  dexterity        Int
  constitution     Int
  intelligence     Int
  wisdom           Int
  charisma         Int
  gold             Int
  experience       Int    @default(0)
  natural_heal     String
  current_zone     String
  current_scene    String

  spell_slots   SpellSlot[]
  chat_message  ChatMessage[]
  active_quests QuestState[]

  user_id       String
  user          User         @relation(fields: [user_id], references: [id])
  gameSessionId String?
  GameSession   GameSession? @relation(fields: [gameSessionId], references: [id])
}

model NpcCharacter {
  id      String        @id @default(cuid())
  base_id String
  base    BaseCharacter @relation(fields: [base_id], references: [id])

  level            Int
  max_hp           Int
  current_hp       Int
  temporary_hp     Int
  armor_class      Int
  initiative       Int
  initiative_bonus Int
  strength         Int
  dexterity        Int
  constitution     Int
  intelligence     Int
  wisdom           Int
  charisma         Int
  gold             Int
  damage           String
  available_quests String[]
  disposition      Disposition @default(NEUTRAL)

  loot_table LootEntry[]

  scene_diff_id String?
  scene_diff    SceneDiff? @relation(fields: [scene_diff_id], references: [id])
}

model AbilityOnCharacter {
  id String @id @default(cuid())

  ability_id   String
  ability      Ability       @relation(fields: [ability_id], references: [id])
  character_id String
  character    BaseCharacter @relation(fields: [character_id], references: [id])
}

model Ability {
  id           String             @id @default(cuid())
  name         String
  description  String?
  cooldown     Int?
  damage_dice  Int?
  ability_type AbilityType
  effect_type  AbilityEffectType?

  characters AbilityOnCharacter[]
}

model SpellSlot {
  id    String  @id @default(cuid())
  level Int
  used  Boolean @default(false)

  player_id String
  player    PlayerCharacter @relation(fields: [player_id], references: [id])
}

model SpellOnCharacter {
  id String @id @default(cuid())

  spell_id     String
  spell        Spell         @relation(fields: [spell_id], references: [id])
  character_id String
  character    BaseCharacter @relation(fields: [character_id], references: [id])
}

model Spell {
  id          String      @id @default(cuid())
  name        String
  description String?
  level       Int
  cooldown    Int?
  range       String?
  damage_dice Int?
  school      SpellSchool

  characters SpellOnCharacter[]
}

model Inventory {
  id       String     @id @default(cuid())
  quantity Int        @default(1)
  equipped Boolean    @default(false)
  slot     EquipSlot?

  item_id      String
  item         Item          @relation(fields: [item_id], references: [id])
  character_id String
  character    BaseCharacter @relation(fields: [character_id], references: [id])
}

model LootEntry {
  id        String @id @default(cuid())
  drop_rate Float  @default(1.0)

  item_id String
  item    Item         @relation(fields: [item_id], references: [id])
  npc_id  String
  npc     NpcCharacter @relation(fields: [npc_id], references: [id])
}

model Item {
  id          String  @id @default(cuid())
  name        String
  description String?
  base_damage Int? // if weapon
  base_armor  Int? // if armor

  Inventory Inventory[]
  LootEntry LootEntry[]
}

model ConditionEffectInstance {
  id        String          @id @default(cuid())
  duration  Int
  intensity Int
  source    String?
  effect    ConditionEffect

  character_id String
  character    BaseCharacter @relation(fields: [character_id], references: [id])
}

model QuestState {
  id           String      @id @default(cuid())
  objectives   Json
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt
  completed_at DateTime?
  status       QuestStatus

  quest_id  String
  quest     QuestDefinition @relation(fields: [quest_id], references: [id])
  player_id String
  player    PlayerCharacter @relation(fields: [player_id], references: [id])
}

model QuestObjective {
  id          String @id @default(cuid())
  description String
  required    Int    @default(1)

  quest_def_id String
  quest        QuestDefinition @relation(fields: [quest_def_id], references: [id])
}

model QuestReward {
  id       String   @id @default(cuid())
  gold     Int      @default(0)
  xp       Int      @default(0)
  item_ids String[]

  quest_def_id String
  quest        QuestDefinition @relation(fields: [quest_def_id], references: [id])
}

model QuestDefinition {
  id                String   @id @default(cuid())
  name              String
  description       String
  level_requirement Int
  quest_type        String
  repeatable        Boolean  @default(false)
  prerequisites     String[] // quest IDs

  objectives QuestObjective[]
  rewards    QuestReward[]
  QuestState QuestState[]
}

model SceneDiff {
  id         String   @id @default(cuid())
  zone       String
  scene_id   String
  changes    Json?
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  NpcCharacter NpcCharacter[]

  game_session_id String
  game_session    GameSession @relation(fields: [game_session_id], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id         String      @id @default(cuid())
  content    String
  created_at DateTime    @default(now())
  updated_at DateTime    @updatedAt
  speaker    SpeakerType
  action     ActionType

  player_id       String?
  player          PlayerCharacter? @relation(fields: [player_id], references: [id])
  game_session_id String
  game_session    GameSession      @relation(fields: [game_session_id], references: [id], onDelete: Cascade)
}

// ====================================================================================
// GAME ENUMS
// ====================================================================================

enum QuestStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum AbilityEffectType {
  DAMAGE
  HEAL
  BUFF
  DEBUFF
  CONTROL
  UTILITY
}

enum SpeakerType {
  PLAYER
  NARRATOR
  SYSTEM
  ERROR
}

enum ActionType {
  ATTACK
  SPELL
  SOCIAL
  INTERACT
  MOVEMENT
  USER_PROMPT
  NARRATE
}

enum CharacterType {
  PLAYER
  NPC
}

enum CreatureType {
  ABERRATION
  BEAST
  CELESTIAL
  CONSTRUCT
  DRAGON
  ELEMENTAL
  FIEND
  GIANT
  HUMANOID
  MONSTROSITY
  OOZE
  PLANT
  UNDEAD
  OTHER
}

enum Disposition {
  FRIENDLY
  NEUTRAL
  AGGRESSIVE
}

enum EquipSlot {
  HEAD
  CHEST
  LEGS
  FEET
  HANDS
  WEAPON
  SHIELD
  ACCESSORY
}

enum SpellSchool {
  ABJURATION
  CONJURATION
  DIVINATION
  ENCHANTMENT
  EVOCATION
  ILLUSION
  NECROMANCY
  TRANSMUTATION
}

enum ConditionEffect {
  BLEEDING
  BLINDING
  CHARMED
  DEAFENED
  FRIGHTENED
  GRAPPLED
  INCAPACITATED
  INVISIBLE
  PARALYZED
  PETRIFIED
  POISONED
  PRONE
  RESTRAINED
  SILENCED
  STUNNED
  UNCONSCIOUS
  EXHAUSTION
}

enum AbilityType {
  MELEE
  RANGED
  SPECIAL
}
